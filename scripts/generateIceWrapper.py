#!/usr/bin/env python3

# Copyright 2020-2023 The Mumble Developers. All rights reserved.
# Use of this source code is governed by a BSD-style license
# that can be found in the LICENSE file at the root of the
# Mumble source tree or at <https://www.mumble.info/LICENSE>.


import argparse
import re
from datetime import datetime
import os

def comment_remover(text):
    def replacer(match):
        s = match.group(0)
        if s.startswith('/'):
            return ""
        else:
            return s
    pattern = re.compile(
        r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        re.DOTALL | re.MULTILINE
    )
    return re.sub(pattern, replacer, text)

def fix_lineEnding(text):
    # Convert from Windows to Unix
    text = text.replace("\r\n", "\n")
    # Convert from old Mac to Unix
    text = text.replace("\r", "\n")

    return text

def create_disclaimerComment():
    return "// This file was auto-generated by scripts/generateIceWrapper.py on " + datetime.now().strftime("%Y-%m-%d") + " -- DO NOT EDIT MANUALLY!\n"

def generateFunction(className, functionName, wrapArgs, callArgs):
    function = "void ::MumbleServer::" + className + "I::" + functionName + "Async(" + (", ".join(wrapArgs)) + ") {\n"
    function += "\t// qWarning() << \"" + functionName + "\" << meta->mp.qsIceSecretRead.isNull() << meta->mp.qsIceSecretRead.isEmpty();\n"
    function += "#ifndef ACCESS_" + className + "_" + functionName + "_ALL\n"
    function += "#\tifdef ACCESS_" + className + "_" + functionName + "_READ\n"
    function += "\tif (!meta->mp.qsIceSecretRead.isNull()) {\n"
    function += "\t\tbool ok = !meta->mp.qsIceSecretRead.isEmpty();\n"
    function += "#\telse\n"
    function += "\tif (!meta->mp.qsIceSecretRead.isNull() || !meta->mp.qsIceSecretWrite.isNull()) {\n"
    function += "\t\tbool ok = !meta->mp.qsIceSecretWrite.isEmpty();\n"
    function += "#\tendif // ACCESS_" + className + "_" + functionName + "_READ\n"
    function += "\t\t::Ice::Context::const_iterator i = current.ctx.find(\"secret\");\n"
    function += "\t\tok = ok && (i != current.ctx.end());\n"
    function += "\t\tif (ok) {\n"
    function += "\t\t\tconst QString &secret = u8((*i).second);\n"
    function += "#\tifdef ACCESS_" + className + "_" + functionName + "_READ\n"
    function += "\t\t\tok = ((secret == meta->mp.qsIceSecretRead) || (secret == meta->mp.qsIceSecretWrite));\n"
    function += "#\telse\n"
    function += "\t\t\tok = (secret == meta->mp.qsIceSecretWrite);\n"
    function += "#\tendif // ACCESS_" + className + "_" + functionName + "_READ\n"
    function += "\t\t}\n"
    function += "\n"
    function += "\t\tif (!ok) {\n"
    function += "\t\t\texception(std::make_exception_ptr(InvalidSecretException()));\n"
    function += "\t\t\treturn;\n"
    function += "\t\t}\n"
    function += "\t}\n"
    function += "#endif // ACCESS_" + className + "_" + functionName + "_ALL\n"
    function += "\n"
    function += "\tExecEvent *ie = new ExecEvent(boost::bind(&impl_" + className + "_" + functionName + ", " + ", ".join(callArgs) + "));\n"
    function += "\tQCoreApplication::instance()->postEvent(mi, ie);\n"
    function += "}\n"

    return function

def get_parameter_pair(s) -> (str, str):
    import re
    match = re.match("([a-zA-Z0-9_]*[a-zA-Z_])", s[::-1])

    reversed_result = match[0][::-1]
    return s[:-len(reversed_result)].strip(), reversed_result.strip()


def iterate_parameters(params: str):
    opening_brackets = "<(["
    closing_brackets = ">)]"
    opening_bracket_stack = []

    it = (i for i, c in enumerate(params) if
          (not opening_bracket_stack and c == ',') or c in opening_brackets or c in closing_brackets)
    ind = 0
    while True:
        try:
            next_index = next(it)
        except StopIteration:
            yield get_parameter_pair(params[ind:])
            break
        if next_index is not None:
            if params[next_index] == ',':
                yield get_parameter_pair(params[ind:next_index])
                ind = next_index + 1
            else:
                bracket = params[next_index]
                try:
                    opening_bracket_stack.append(opening_brackets.index(bracket))
                except ValueError:
                    if not opening_bracket_stack:
                        raise RuntimeError(f'There was no opening bracket for closing bracket {bracket}')
                    else:
                        matching_bracket = opening_bracket_stack.pop()
                        try:
                            closingBracketIndex = closing_brackets.index(bracket)
                            if matching_bracket != closingBracketIndex:
                                raise RuntimeError(
                                    f'Opening bracket {matching_bracket} does not match closing bracket {bracket}')
                        except ValueError:
                            raise RuntimeError(f'There was no closing bracket {bracket}')




def main():
    parser = argparse.ArgumentParser(description="Generates the wrapper files needed for the ICE server-interface")
    parser.add_argument("-i", "--ice-file", help="Path to the ICE specification file (*.ice)", metavar="PATH")
    parser.add_argument("-g", "--generated-ice-header", help="Path to the header file that was generated by ICE", metavar="PATH")
    parser.add_argument("-o", "--out-file", help="Path to the file to write the generated output to. If omitted, the content will be written to std::out", metavar="PATH")
    parser.add_argument("-q", "--quiet", action="store_true", help="Don't display used file paths")

    args = parser.parse_args()

    scriptPath = os.path.realpath(__file__)
    rootDir = os.path.dirname(os.path.dirname(scriptPath))

    if args.ice_file is None:
        # Try to figure out the path to the ice-file (MumbleServer.ice)
        args.ice_file = os.path.join(rootDir, "src", "murmur", "MumbleServer.ice")
    if args.generated_ice_header is None:
        # Try to figure out path to the generated header file (in the build dir)
        args.generated_ice_header = os.path.join(rootDir, "build", "src", "murmur", "MumbleServer.h")

    if not args.quiet:
        print("Using ICE-file at                   \"%s\"" % args.ice_file)
        print("Using ICE-generated header file at  \"%s\"" % args.generated_ice_header)


    iceSpec = fix_lineEnding(open(args.ice_file, "r").read())
    generatedIceHeader = fix_lineEnding(open(args.generated_ice_header, "r").read())

    # remove comments from the iceSpec
    iceSpec = comment_remover(iceSpec)
    # Remove all tabs from iceSpec
    iceSpec = iceSpec.replace("\t", "")
    # Remove empty lines form iceSpec
    iceSpec = iceSpec.replace("\n\n", "\n")

    # Escape all special characters so that iceSpec can be used in a std::string ctor
    iceSpec = iceSpec.replace("\"", "\\\"") # quotes
    iceSpec = iceSpec.replace("\n", "\\n")  # newlines

    wrapperContent = create_disclaimerComment()

    # Include boost-bind as we'll need it later
    wrapperContent += "\n#include <boost/bind/bind.hpp>\n\n"


    className = ""
    responseTypes = {}
    for currentLine in generatedIceHeader.split("\n"):
        currentLine = currentLine.strip()

        if not currentLine:
            # Skip empty lines
            continue

        # find class name
        match = re.match("^class\s+([a-zA-Z_][a-zA-Z0-9_]+)\s*:\s*public\s+virtual\s+::Ice::Object", currentLine)
        if match:
            className = match.group(1)
            if not className in ["Server", "Meta"]:
                className = None
                
        match = re.match("virtual\s+void\s+([a-zA-Z_][a-zA-Z0-9_]+)Async\s*\((.*?)\)\s*=\s*0\s*;", currentLine)
        if match:
            if not className:
                raise RuntimeError("Expected a className to be found at this time")
            # match = re.match("virtual\s+void\s+(.+)_async\(const\s+(.+?)&\s*\w*,(.*)\s+const\s+::Ice::Current&", currentLine)
            functionName = match.group(1)
            arguments = match.group(2)

            if functionName == "getSlice":
                # getSlice is handled separately
                continue

            targetClass = className

            wrapArgs = []
            callArgs = []

            
            for currentArg in iterate_parameters(arguments):
                if not currentArg or currentArg[1] == "current":
                    # skip empty entries
                    continue
                wrapArgs.append("%s %s" % (currentArg[0], currentArg[1]))
                callArgs.append("%s" % currentArg[1])

            if targetClass == "Server":
                callArgs.append("QString::fromStdString(current.id.name).toInt()")
            else:
                callArgs.append("current.adapter")


            wrapArgs.append("const ::Ice::Current &current")

            wrapperContent += generateFunction(targetClass, functionName, wrapArgs, callArgs) + "\n"


    wrapperContent += "void ::MumbleServer::MetaI::getSliceAsync(::std::function<void(const ::std::string& returnValue)> response, ::std::function<void(::std::exception_ptr)>, const Ice::Current&) {\n"
    wrapperContent += "\tresponse(std::string(\"" + iceSpec + "\"));\n"
    wrapperContent += "}\n"


    if args.out_file is None:
        # Write to std::out
        print(wrapperContent)
    else:
        # Write to file
        outFile = open(args.out_file, "w")
        outFile.write(wrapperContent)



main()
